#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Mon Mar 19 12:07:40 2018

@author: meira
"""

import matplotlib
matplotlib.use('TkAgg')

#taken from assignment

import networkx as nx
import numpy
#import matplotlib.pyplot as plt

from networkx.algorithms import bipartite

#import matplotlib
#matplotlib.use('TkAgg')

import pylab as PL
import random as RD



RD.seed()

PoorVAProb = 0.2

#https://networkx.github.io/documentation/stable/reference/algorithms/bipartite.html
B = nx.Graph()  #nx path graph?
#B.pos = nx.spring_layout(B)
B.add_nodes_from([1,2,3,4, 5, 6], bipartite=0) #perceivers, top nodes
# Add the node attribute "bipartite" - Targets = 1
B.add_nodes_from(['a','b','c', 'd','e', 'f', 'g', 'h', 'm', 'q'], bipartite=1)
B.add_edges_from([(1,'a'), (1,'e'), (1,'f'), (2,'b'), (2,'e'), (2,'g'), 
                  (3,'c'), (3,'e'), (3,'h'),(3,'g'),(4,'d'), (5, 'm'), (6, 'q')])


#to check
nx.is_connected(B)

bottom_nodes, top_nodes = bipartite.sets(B)

#get the 2node sets
perceivers = {n for n, d in B.nodes(data=True) if d['bipartite']==0} # perceivers top
targets = set(B) - perceivers


#SET INITIAL WEIGHTS FOR EXPECTATIONS

B.node['a']['VA.type'] = 'personal assistant'
B.node['b']['VA.type'] = 'personal assistant'
B.node['c']['VA.type'] = 'personal assistant'
B.node['d']['VA.type'] = 'personal assistant'
B.node['m']['VA.type'] = 'personal assistant'
B.node['e']['VA.type'] = 'bank assistant'  # could open up learning through neighbors since public interaction
B.node['f']['VA.type'] = 'customer service assistant'
B.node['g']['VA.type'] = 'customer service assistant'
B.node['h']['VA.type'] = 'purchasing assistant'
B.node['q']['VA.type'] = 'health assistant'

#B.node['1']['expectation.1'] = 20 #an independent expectation? or owned by edge?
#say there are x factors involved in expectation. start with 3
#FIXME values are placeholders

#https://networkx.github.io/documentation/stable/release/migration_guide_from_1.x_to_2.0.html
#B.add_weighted_edges_from([(1, 2, 0.5), (3, 1, 0.75)])
B.adj[1]['a']['expectation.1'] = 20 #array.1 #FIXME to define array somewhere 
B.adj[1]['a']['expectation.2'] = 20 
B.adj[1]['a']['expectation.3'] = 20 

B.adj[1]['e']['expectation.1'] = 20 
B.adj[1]['e']['expectation.2'] = 20 
B.adj[1]['e']['expectation.3'] = 20 

B.adj[1]['f']['expectation.1'] = 20 #owned by edge so part of relationship
B.adj[1]['f']['expectation.2'] = 20 
B.adj[1]['f']['expectation.3'] = 20 #owned by edge so part of relationship

B.adj[2]['b']['expectation.1'] = 20 
B.adj[2]['b']['expectation.2'] = 20 
B.adj[2]['b']['expectation.3'] = 20 

B.adj[2]['e']['expectation.1'] = 20 
B.adj[2]['e']['expectation.2'] = 20 
B.adj[2]['e']['expectation.3'] = 20 

B.adj[2]['g']['expectation.1'] = 20 
B.adj[2]['g']['expectation.2'] = 20 
B.adj[2]['g']['expectation.3'] = 20 

B.adj[3]['c']['expectation.1'] = 20 
B.adj[3]['c']['expectation.2'] = 20 
B.adj[3]['c']['expectation.3'] = 20 

B.adj[3]['e']['expectation.1'] = 20 
B.adj[3]['e']['expectation.2'] = 20 
B.adj[3]['e']['expectation.3'] = 20 

B.adj[3]['h']['expectation.1'] = 20 
B.adj[3]['h']['expectation.2'] = 20 
B.adj[3]['h']['expectation.3'] = 20 

B.adj[3]['g']['expectation.1'] = 20 
B.adj[3]['g']['expectation.2'] = 20 
B.adj[3]['g']['expectation.3'] = 20 

B.adj[4]['d']['expectation.1'] = 20 
B.adj[4]['d']['expectation.2'] = 20 
B.adj[4]['d']['expectation.3'] = 20 

B.adj[5]['m']['expectation.1'] = 20 
B.adj[5]['m']['expectation.2'] = 20 
B.adj[5]['m']['expectation.3'] = 20 

B.adj[6]['q']['expectation.1'] = 20 
B.adj[6]['q']['expectation.2'] = 20 
B.adj[6]['q']['expectation.3'] = 20 

#setting performance variables
##Starting with performance variables as being owned by VA. but really should be owned by edge...

B.node['a']['performance.1'] = 0
B.node['a']['performance.2'] = 0
B.node['a']['performance.3'] = 0

B.node['b']['performance.1'] = 0
B.node['b']['performance.2'] = 0
B.node['b']['performance.3'] = 0

B.node['c']['performance.1'] = 0
B.node['c']['performance.2'] = 0
B.node['c']['performance.3'] = 0

B.node['d']['performance.1'] = 0
B.node['d']['performance.2'] = 0
B.node['d']['performance.3'] = 0

B.node['e']['performance.1'] = 0
B.node['e']['performance.2'] = 0
B.node['e']['performance.3'] = 0

B.node['f']['performance.1'] = 0
B.node['f']['performance.2'] = 0
B.node['f']['performance.3'] = 0

B.node['g']['performance.1'] = 0
B.node['g']['performance.2'] = 0
B.node['g']['performance.3'] = 0

B.node['h']['performance.1'] = 0
B.node['h']['performance.2'] = 0
B.node['h']['performance.3'] = 0

B.node['m']['performance.1'] = 0
B.node['m']['performance.2'] = 0
B.node['m']['performance.3'] = 0

B.node['q']['performance.1'] = 0
B.node['q']['performance.2'] = 0
B.node['q']['performance.3'] = 0

def init():
    global B, nextB
    
    time = 0
    
    B = nx.Graph() # do i need to state this again?
    
    nextB = B.copy()
    #do i need to return anythign else?
    
def draw():
    PL.cla()
    nx.draw(B) #, pos = positions, edge_color = [col[network.node[n]['state']] for n in network.nodes()])
    PL.axis('image')
    PL.title('t = ' + str(time))
    

def step():
    global time, B, nextB

    time += 1

 
    for i in B.nodes(): #for i in perceiver():
        for j in B.adj():
        #if B.node[targets]['performance.1'] == B.adj[perceivers][targets]['expectation.1'] : 1MC
        if B.node[i]['performance.1'] == B.adj[i][i]['expectation.1'] :
           # nextB.node[i]['state'] = 100 #FIXME placeholder value
            nextB.adj[i][i]['expectation.1'] = 50
            
                if B.adj[j]['expectation.1'] < 60 : #if it's generally high
                    if RD.random() < PoorVAProb:
                   # if RD.random() < infectionProb:
                        nextB.node[i]['expectation.1'] = 5
                        break
                    else: # adaptive link cutting behavior
                        nextB.node[i]['expectation.1'] = B.node[i]['expectation.1'] + 10
        if B.node[targets]['performance.1'] < B.adj[perceivers][targets]['expectation.1'] :        # if B.node[target]['performance.1'] < B.adj[perceiver][target]['expectation.1']

           nextB.adj[perceivers][targets]['expectation.1'] = 10
           
                
        else:
             nextB.adj[perceivers][targets]['expectation.1'] = B.adj[perceivers][targets]['expectation.1'] + 40
                
    del B
    B = nextB.copy()   
    
import pycxsimulator
pycxsimulator.GUI().start(func=[init,draw,step])